(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{638:function(_,v,e){"use strict";e.r(v);var t=e(6),a=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h2",{attrs:{id:"_1-http的历史"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-http的历史"}},[_._v("#")]),_._v(" 1.HTTP的历史")]),_._v(" "),e("p",[_._v("早在 "),e("code",[_._v("HTTP")]),_._v("  建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的 web 服务器上，用户端通过浏览器访问url地址来获取网页的显示内容，但是到了 WEB2.0  以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的 "),e("code",[_._v("HTML")]),_._v(" 页面有了  "),e("code",[_._v("CSS")]),_._v("，"),e("code",[_._v("Javascript")]),_._v("，来丰富我们的页面展示，当 ajax 的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于"),e("code",[_._v("HTTP")]),_._v(" 协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和 PC  相比，手机端的网络情况更加复杂，这使得我们开始了不得不对 "),e("code",[_._v("HTTP")]),_._v(" 进行深入理解并不断优化过程中。")]),_._v(" "),e("h2",{attrs:{id:"_2-http1-0和http1-1的一些区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-http1-0和http1-1的一些区别"}},[_._v("#")]),_._v(" 2.HTTP1.0和HTTP1.1的一些区别")]),_._v(" "),e("p",[e("code",[_._v("HTTP1.0")]),_._v("最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而"),e("code",[_._v("HTTP1.1")]),_._v("则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时"),e("code",[_._v("HTTP1.1")]),_._v("也是当前使用最为广泛的"),e("code",[_._v("HTTP")]),_._v("协议。 主要区别主要体现在：")]),_._v(" "),e("h4",{attrs:{id:"_2-1-缓存处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-缓存处理"}},[_._v("#")]),_._v(" 2.1 缓存处理")]),_._v(" "),e("p",[_._v("在"),e("code",[_._v("HTTP1.0")]),_._v("中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，"),e("code",[_._v("HTTP1.1")]),_._v("则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。")]),_._v(" "),e("h4",{attrs:{id:"_2-2-带宽优化及网络连接的使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-带宽优化及网络连接的使用"}},[_._v("#")]),_._v(" 2.2 带宽优化及网络连接的使用")]),_._v(" "),e("p",[e("code",[_._v("HTTP1.0")]),_._v("中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，"),e("code",[_._v("HTTP1.1")]),_._v("则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。")]),_._v(" "),e("h4",{attrs:{id:"_2-3-错误通知的管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-错误通知的管理"}},[_._v("#")]),_._v(" 2.3 错误通知的管理")]),_._v(" "),e("p",[_._v("在"),e("code",[_._v("HTTP1.1")]),_._v("中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。")]),_._v(" "),e("h4",{attrs:{id:"_2-4-host头处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-host头处理"}},[_._v("#")]),_._v(" 2.4 Host头处理")]),_._v(" "),e("p",[_._v("在"),e("code",[_._v("HTTP1.0")]),_._v("中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web  Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。")]),_._v(" "),e("h4",{attrs:{id:"_2-5-长连接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-长连接"}},[_._v("#")]),_._v(" 2.5 长连接")]),_._v(" "),e("p",[e("code",[_._v("HTTP 1.1")]),_._v("支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在"),e("code",[_._v("HTTP1.1")]),_._v("中默认开启"),e("code",[_._v("Connection： keep-alive")]),_._v("，一定程度上弥补了"),e("code",[_._v("HTTP1.0")]),_._v("每次请求都要创建连接的缺点。")]),_._v(" "),e("h2",{attrs:{id:"_3-https与http的一些区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-https与http的一些区别"}},[_._v("#")]),_._v(" 3.HTTPS与HTTP的一些区别")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("HTTPS")]),_._v("协议需要到CA申请证书，一般免费证书很少，需要交费。")]),_._v(" "),e("li",[e("code",[_._v("HTTP")]),_._v("协议运行在"),e("code",[_._v("TCP")]),_._v("之上，所有传输的内容都是明文，"),e("code",[_._v("HTTPS")]),_._v("运行在"),e("code",[_._v("SSL/TLS")]),_._v("之上，"),e("code",[_._v("SSL/TLS")]),_._v("运行在"),e("code",[_._v("TCP")]),_._v("之上，所有传输的内容都经过加密的。")]),_._v(" "),e("li",[e("code",[_._v("HTTP")]),_._v("和"),e("code",[_._v("HTTPS")]),_._v("使用的是完全不同的连接方式，用的端口也不一样，前者是"),e("code",[_._v("80")]),_._v("，后者是"),e("code",[_._v("443")]),_._v("。")]),_._v(" "),e("li",[e("code",[_._v("HTTPS")]),_._v("可以有效的防止运营商劫持，解决了防劫持的一个大问题。")])]),_._v(" "),e("h2",{attrs:{id:"_4-http2-0和http1-x相比的新特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-http2-0和http1-x相比的新特性"}},[_._v("#")]),_._v(" 4.HTTP2.0和HTTP1.X相比的新特性")]),_._v(" "),e("h3",{attrs:{id:"_4-1-新的二进制格式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-新的二进制格式"}},[_._v("#")]),_._v(" 4.1 新的二进制格式")]),_._v(" "),e("p",[_._v("新的二进制格式（Binary  Format），"),e("code",[_._v("HTTP1.x")]),_._v("的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑"),e("code",[_._v("HTTP2.0")]),_._v("的协议解析决定采用二进制格式，实现方便且健壮。")]),_._v(" "),e("h3",{attrs:{id:"_4-2-多路复用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-多路复用"}},[_._v("#")]),_._v(" 4.2 多路复用")]),_._v(" "),e("p",[e("code",[_._v("多路复用")]),_._v("（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。")]),_._v(" "),e("h3",{attrs:{id:"_4-3-header压缩"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-header压缩"}},[_._v("#")]),_._v(" 4.3 header压缩")]),_._v(" "),e("p",[e("code",[_._v("header压缩")]),_._v("，如上文中所言，对前面提到过"),e("code",[_._v("HTTP1.x")]),_._v("的header带有大量信息，而且每次都要重复发送，"),e("code",[_._v("HTTP2.0")]),_._v("使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。")]),_._v(" "),e("h3",{attrs:{id:"_4-4-服务端推送"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-服务端推送"}},[_._v("#")]),_._v(" 4.4 服务端推送")]),_._v(" "),e("p",[_._v("服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。")]),_._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[_._v("#")]),_._v(" 总结")]),_._v(" "),e("p",[e("strong",[_._v("HTTP/0.9")])]),_._v(" "),e("p",[e("code",[_._v("HTTP/0.9")]),_._v(" 并没有考虑太过复杂的内容，仅仅是用来传输体积很小的文件。")]),_._v(" "),e("p",[e("strong",[_._v("HTTP/1.0")])]),_._v(" "),e("ul",[e("li",[_._v("应对 "),e("code",[_._v("HTTP/0.9")]),_._v(" 出现的问题，进行了支持多类型文件下载等内容的优化。")]),_._v(" "),e("li",[e("code",[_._v("HTTP/1.0")]),_._v(" 定义了三种请求方法："),e("code",[_._v("GET")]),_._v("，"),e("code",[_._v("POST")]),_._v(" 和 "),e("code",[_._v("HEAD")]),_._v(" 方法。")])]),_._v(" "),e("p",[e("strong",[_._v("HTTP/1.1")])]),_._v(" "),e("ul",[e("li",[e("code",[_._v("HTTP/1.1")]),_._v(" 默认开启 "),e("code",[_._v("Connection: keep-alive")]),_._v("，让一个 "),e("code",[_._v("TCP")]),_._v(" 连接能重复发送/接收多次 "),e("code",[_._v("HTTP")]),_._v(" 请求。")]),_._v(" "),e("li",[e("code",[_._v("HTTP/1.1")]),_._v(" 新增了六种请求方法："),e("code",[_._v("OPTIONS")]),_._v("、"),e("code",[_._v("PUT")]),_._v("、"),e("code",[_._v("PATCH")]),_._v("、"),e("code",[_._v("DELETE")]),_._v("、"),e("code",[_._v("TRACE")]),_._v(" 和 "),e("code",[_._v("CONNECT")]),_._v(" 方法")])]),_._v(" "),e("p",[e("strong",[_._v("HTTP/2.0")])]),_._v(" "),e("ul",[e("li",[e("strong",[_._v("头部压缩")]),_._v("："),e("code",[_._v("HTTP/2")]),_._v(" 采用"),e("code",[_._v("hpack算法")]),_._v("压缩消息头，减少了传输数据的大小")]),_._v(" "),e("li",[e("strong",[_._v("多路复用")]),_._v("：即多个请求都通过一个 "),e("code",[_._v("TCP")]),_._v(" 连接并发地完成")]),_._v(" "),e("li",[e("strong",[_._v("服务器推送")]),_._v("：服务端能够主动把资源推送给客户端")])]),_._v(" "),e("p",[e("strong",[_._v("HTTP/3.0")])]),_._v(" "),e("ul",[e("li",[_._v("实现了类似 "),e("code",[_._v("TCP")]),_._v(" 的流量控制、传输可靠性的功能。")]),_._v(" "),e("li",[_._v("集成了 "),e("code",[_._v("TLS")]),_._v(" 加密功能。")]),_._v(" "),e("li",[_._v("实现了 "),e("code",[_._v("HTTP/2")]),_._v(" 中的多路复用功能。")]),_._v(" "),e("li",[_._v("实现了快速握手功能。")])])])}),[],!1,null,null,null);v.default=a.exports}}]);