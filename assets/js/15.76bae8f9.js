(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{547:function(t,a,e){t.exports=e.p+"assets/img/1694678-a839a0c606ff4780.ae2c06ce.png"},548:function(t,a,e){t.exports=e.p+"assets/img/1624694337-5a8fcee951762_articlex.73e87213.png"},634:function(t,a,e){"use strict";e.r(a);var r=e(6),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"_1-生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-生命周期"}},[t._v("#")]),t._v(" 1.生命周期")]),t._v(" "),r("p",[r("img",{attrs:{src:e(547),alt:"1694678-a839a0c606ff4780"}})]),t._v(" "),r("h3",{attrs:{id:"_1-1-beforecreate"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-beforecreate"}},[t._v("#")]),t._v(" 1.1 beforeCreate")]),t._v(" "),r("p",[t._v("实例组件刚创建，元素DOM和数据都还没有初始化。")]),t._v(" "),r("h3",{attrs:{id:"_1-2-created"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-created"}},[t._v("#")]),t._v(" 1.2 created")]),t._v(" "),r("p",[t._v("数据data已经初始化完成，方法也已经可以调用，但是DOM未渲染。有人问了，请求都是异步的，并不会阻碍实例加载。这是我个人水平的问题，这边改正，在这个周期里面，请求因为是异步的，不会阻碍实例加载，除非是那些同步操走才会导致页面空白。这样说来，在这个周期里面进行请求，渲染速度反而会更快。")]),t._v(" "),r("h3",{attrs:{id:"_1-3-beforemount"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-beforemount"}},[t._v("#")]),t._v(" 1.3 beforeMount")]),t._v(" "),r("p",[t._v("DOM未完成挂载，数据也初始化完成，但是数据的双向绑定还是显示{{}}，这是因为Vue采用了Virtual DOM（虚拟Dom）技术。")]),t._v(" "),r("h3",{attrs:{id:"_1-4-mounted"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-mounted"}},[t._v("#")]),t._v(" 1.4 mounted")]),t._v(" "),r("p",[t._v("数据和DOM都完成挂载，在上一个周期占位的数据把值给渲染进去。可以在这边请求，不过created请求会更好一些。这个周期适合执行初始化需要操作DOM的方法。")]),t._v(" "),r("h3",{attrs:{id:"_1-5-beforeupdate"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-beforeupdate"}},[t._v("#")]),t._v(" 1.5 beforeUpdate")]),t._v(" "),r("p",[t._v("只要是页面数据改变了都会触发，数据更新之前，页面数据还是原来的数据，当你请求赋值一个数据的时候会执行这个周期，如果没有数据改变不执行。")]),t._v(" "),r("h3",{attrs:{id:"_1-6-updated"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-updated"}},[t._v("#")]),t._v(" 1.6 updated")]),t._v(" "),r("p",[t._v("只要是页面数据改变了都会触发，数据更新完毕，页面的数据是更新完成的。beforeUpdate和updated要谨慎使用，因为页面更新数据的时候都会触发，在这里操作数据很影响性能和容易死循环。")]),t._v(" "),r("h3",{attrs:{id:"_1-7-beforedestroy"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-beforedestroy"}},[t._v("#")]),t._v(" 1.7 beforeDestroy")]),t._v(" "),r("p",[t._v("这个周期是在组件销毁之前执行，在我项目开发中，觉得这个其实有点类似路由钩子beforeRouterLeave,都是在路由离开的时候执行，只不过beforeDestroy无法阻止路由跳转，但是可以做一些路由离开的时候操作，因为这个周期里面还可以使用data和method。比如一个倒计时组件，如果在路由跳转的时候没有清除，这个定时器还是在的，这时候就可以在这个里面清除计时器。")]),t._v(" "),r("h3",{attrs:{id:"_1-8-destroyed"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-8-destroyed"}},[t._v("#")]),t._v(" 1.8 Destroyed")]),t._v(" "),r("p",[t._v("说实在的，我还真的不知道这个周期跟beforeDestroy有什么区别，我在这个周期里面调用data的数据和methods的方法都能调用，所以我会觉得跟beforeDestroy是一样的。")]),t._v(" "),r("h2",{attrs:{id:"_2-数据劫持和发布订阅模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-数据劫持和发布订阅模式"}},[t._v("#")]),t._v(" 2.数据劫持和发布订阅模式")]),t._v(" "),r("p",[r("img",{attrs:{src:e(548),alt:"1624694337-5a8fcee951762_articlex"}})]),t._v(" "),r("h3",{attrs:{id:"_2-1-数据劫持"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-数据劫持"}},[t._v("#")]),t._v(" 2.1 数据劫持")]),t._v(" "),r("p",[t._v("vue2.0主要是通过Object.defineProperty()来劫持对象属性中的getter和setter，并种下一个监听器，当数据发生变化的时候发出通知。")]),t._v(" "),r("h3",{attrs:{id:"_2-2-发布订阅模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-发布订阅模式"}},[t._v("#")]),t._v(" 2.2 发布订阅模式")]),t._v(" "),r("p",[t._v("发布订阅模式又称为观察者模式，它定义的是一种一对多的依赖关系，当一个状态发生改变的时候所有与这个状态相关的对象都会收到通知。举个现实生活中的栗子，比如现在路人甲和路人乙到售楼处看房，其中路人甲看中了a和b两套房子，路人乙看中了b和c两套房子，但是房子太好卖了都售罄了，然后就分别把自己的电话给售楼处的小姐姐登记一下，然后当相关的房子有最新的消息，售楼处的小姐姐就打个电话通知一下。")]),t._v(" "),r("h2",{attrs:{id:"_3-vue中的data必须为一个函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue中的data必须为一个函数"}},[t._v("#")]),t._v(" 3.vue中的data必须为一个函数")]),t._v(" "),r("h3",{attrs:{id:"_3-1-堆内存和栈内存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-堆内存和栈内存"}},[t._v("#")]),t._v(" 3.1 堆内存和栈内存")]),t._v(" "),r("h4",{attrs:{id:"_3-1-1-堆内存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-1-堆内存"}},[t._v("#")]),t._v(" 3.1.1 堆内存")]),t._v(" "),r("p",[t._v("队列优先,先进先出。用于复杂数据类型（引用类型）分配空间，例如数组对象、object对象（引用类型的值通常大小不固定，所以被存储在堆内存中，不会自动释放）；它是运行时动态分配内存的，因此存取速度较慢。")]),t._v(" "),r("h4",{attrs:{id:"_3-1-2-栈内存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-2-栈内存"}},[t._v("#")]),t._v(" 3.1.2 栈内存")]),t._v(" "),r("p",[t._v("先进后出。主要存放一些基本类型（Undefined、Null、Boolean、Number 和 String）的变量和对象的引用（基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中，会自动释放）")]),t._v(" "),r("h3",{attrs:{id:"_3-2-类别引用数据类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-类别引用数据类型"}},[t._v("#")]),t._v(" 3.2 类别引用数据类型")]),t._v(" "),r("p",[t._v("Object是引用数据类型，存储在堆内存中，如果不用function返回，每个组件的data都是内存的同一个地址，一个数据改变了其他也改变了；")]),t._v(" "),r("p",[t._v("JavaScript只有函数构成作用域(注意理解作用域，只有函数{}构成作用域,对象的{}以及if(){}都不构成作用域),data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立，不会相互影响。")]),t._v(" "),r("h2",{attrs:{id:"_4-vue组件传参"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-vue组件传参"}},[t._v("#")]),t._v(" 4.vue组件传参")]),t._v(" "),r("p",[t._v("（1）父子组件传参")]),t._v(" "),r("p",[t._v("父组件传给子组件：子组件通过props方法接受数据;\n子组件传给父组件：$emit方法传递参数")]),t._v(" "),r("p",[t._v("（2）使用bus")]),t._v(" "),r("p",[t._v("（3）使用vuex")]),t._v(" "),r("h2",{attrs:{id:"_5-vue的路由模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-vue的路由模式"}},[t._v("#")]),t._v(" 5.vue的路由模式")]),t._v(" "),r("h3",{attrs:{id:"_5-1-hash模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-hash模式"}},[t._v("#")]),t._v(" 5.1 hash模式")]),t._v(" "),r("p",[t._v("在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；\n特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。\nhash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。")]),t._v(" "),r("h3",{attrs:{id:"_5-2-history模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-history模式"}},[t._v("#")]),t._v(" 5.2 history模式")]),t._v(" "),r("p",[t._v("history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。\nhistory 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”")])])}),[],!1,null,null,null);a.default=s.exports}}]);