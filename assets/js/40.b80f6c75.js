(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{645:function(e,a,s){"use strict";s.r(a);var _=s(6),v=Object(_.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"浏览器缓存-http缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存-http缓存"}},[e._v("#")]),e._v(" 浏览器缓存(HTTP缓存)")]),e._v(" "),s("p",[e._v("其机制是根据HTTP报文的缓存标识进行的。")]),e._v(" "),s("p",[e._v("过程：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，若是，则将请求结果和缓存标识存入浏览器缓存中。")]),e._v(" "),s("h3",{attrs:{id:"_1-缓存类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-缓存类型"}},[e._v("#")]),e._v(" 1.缓存类型")]),e._v(" "),s("h4",{attrs:{id:"_1-1-强缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-强缓存"}},[e._v("#")]),e._v(" 1.1 强缓存")]),e._v(" "),s("p",[e._v("强缓存是利用 http 头中的 "),s("code",[e._v("Expires")]),e._v(" 和 "),s("code",[e._v("Cache-Control")]),e._v(" 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 "),s("code",[e._v("expires")]),e._v(" 和 "),s("code",[e._v("cache-control")]),e._v(" 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。")]),e._v(" "),s("p",[s("code",[e._v("expires")]),e._v(" 是一个时间戳，二次请求我们试图向服务器请求资源，浏览器就会先对比本地时间和 "),s("code",[e._v("expires")]),e._v(" 的时间戳，如果本地时间小于 "),s("code",[e._v("expires")]),e._v(" 设定的过期时间，那么就直接去缓存中取这个资源。")]),e._v(" "),s("p",[e._v("它最大的问题在于对“本地时间”有很大的依赖。如果服务端和客户端的时间设置可能不同，或者我直接手动去把客户端的时间改掉，那么 "),s("code",[e._v("expires")]),e._v(" 将无法达到我们的预期。所以我们有第二种方法"),s("code",[e._v("Cache-Control")]),e._v("。")]),e._v(" "),s("p",[s("code",[e._v("Cache-Control")]),e._v(" 是一个时间长度，我们通过 "),s("code",[e._v("max-age")]),e._v(" 来控制资源的有效期，它意味着该资源在时间长度以内都是有效的，完美地规避了时间戳带来的潜在问题。它的优先级更高，当两者同时出现的时候我们以"),s("code",[e._v("Cache-Control")]),e._v("为准。")]),e._v(" "),s("p",[s("code",[e._v("Cache-Control")]),e._v("有如下字段比较常见。")]),e._v(" "),s("ol",[s("li",[s("code",[e._v("s-maxage")]),e._v(" 和 "),s("code",[e._v("max-age")])])]),e._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[e._v("cache"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v("control"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" max"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v("age"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("3600")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" s"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v("maxage"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("31536000")]),e._v("\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[s("code",[e._v("s-maxage")]),e._v("的优先级比"),s("code",[e._v("max-age")]),e._v("高。"),s("code",[e._v("s-maxage")]),e._v("是代理服务器的缓存时间。客户端中我们以"),s("code",[e._v("max-age")]),e._v("为准。")]),e._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[s("code",[e._v("public")]),e._v("与"),s("code",[e._v("private")])])]),e._v(" "),s("p",[s("code",[e._v("public")]),e._v("与"),s("code",[e._v("private")]),e._v(" 是针对资源是否能够被代理服务缓存而存在的一组对立概念。如果我们为资源设置了 "),s("code",[e._v("public")]),e._v("，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置了 private，则该资源只能被浏览器缓存。"),s("code",[e._v("private")]),e._v(" 为默认值。")]),e._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[s("code",[e._v("no-store")]),e._v(" 与 "),s("code",[e._v("no-cache")])])]),e._v(" "),s("p",[s("code",[e._v("no-cache")]),e._v(" 绕开了浏览器：我们为资源设置了 "),s("code",[e._v("no-cache")]),e._v(" 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期（协商缓存）。")]),e._v(" "),s("p",[s("code",[e._v("no-store")]),e._v(" 比较绝情，顾名思义就是不使用任何缓存策略。在 "),s("code",[e._v("no-cache")]),e._v(" 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。")]),e._v(" "),s("h4",{attrs:{id:"_1-2-协商缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-协商缓存"}},[e._v("#")]),e._v(" "),s("strong",[e._v("1.2 协商缓存")])]),e._v(" "),s("p",[e._v("协商缓存依赖于服务端与浏览器之间的通信。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，对应状态码是304。")]),e._v(" "),s("p",[e._v("协商缓存有两个字段："),s("code",[e._v("Last-Modified")]),e._v(" 和 "),s("code",[e._v("Etag")])]),e._v(" "),s("p",[s("code",[e._v("Last-Modified")]),e._v(" 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：")]),e._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[e._v("Last"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v("Modified"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" Fri"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("25")]),e._v(" Oct "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("2018")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("06")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("35")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("57")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[e._v("GMT")]),e._v("\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 "),s("code",[e._v("last-modified")]),e._v("值：")]),e._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[e._v("Last"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v("Modified"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" Fri"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("25")]),e._v(" Oct "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("2018")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("06")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("35")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("57")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[e._v("GMT")]),e._v("\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的"),s("code",[e._v("Last-Modified")]),e._v("值；否则，返回如上图的 304 响应，Response Headers 不会再添加 "),s("code",[e._v("Last-Modified")]),e._v(" 字段。")]),e._v(" "),s("p",[s("strong",[e._v("缺点与弊端：")])]),e._v(" "),s("ul",[s("li",[e._v("手动改动服务器内容，即使没有修改内容，但服务器也认为是新的内容。进而引发一次完整的响应——不该重新请求的时候，也会重新请求。")]),e._v(" "),s("li",[e._v("修改文件速度过快（比如花了 100ms 完成了改动），由于 "),s("code",[e._v("If-Modified-Since")]),e._v(" 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。")])]),e._v(" "),s("p",[e._v("为了解决问题，"),s("code",[e._v("Etag")]),e._v("出现了。"),s("code",[e._v("Etag")]),e._v(" 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 "),s("code",[e._v("Etag")]),e._v(" 就是不同的，反之亦然。因此 "),s("code",[e._v("Etag")]),e._v(" 能够精准地感知文件的变化。")]),e._v(" "),s("p",[s("code",[e._v("Etag")]),e._v(" 和 "),s("code",[e._v("Last-Modified")]),e._v(" 类似，当首次请求时，我们会在响应头里获取到一个最初的标识符字符串，它可以是这样的：")]),e._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[e._v("ETag"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[e._v("W")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"2a3b-1602480f459"')]),e._v("\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("那么下一次请求时，请求头里就会带上一个值相同的、名为 if-None-Match 的字符串供服务端比对了：")]),e._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[e._v("If"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v("None"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v("Match"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[e._v("W")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"2a3b-1602480f459"')]),e._v("\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[s("code",[e._v("Etag")]),e._v(" 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。因此启用 "),s("code",[e._v("Etag")]),e._v(" 需要我们审时度势。"),s("code",[e._v("Etag")]),e._v("的优先级比"),s("code",[e._v("Last-Modified")]),e._v("高。")]),e._v(" "),s("h4",{attrs:{id:"_1-3-启发式缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-启发式缓存"}},[e._v("#")]),e._v(" 1.3 启发式缓存")]),e._v(" "),s("p",[e._v("如果响应中未显示"),s("code",[e._v("Expires")]),e._v("，"),s("code",[e._v("Cache-Control：max-age")]),e._v("或"),s("code",[e._v("Cache-Control：s-maxage")]),e._v("，并且响应中不包含其他有关缓存的限制，缓存可以使用启发式方法计算新鲜度寿命。通常会根据响应头中的2个时间字段 "),s("code",[e._v("Date")]),e._v(" 减去 "),s("code",[e._v("Last-Modified")]),e._v(" 值的 10% 作为缓存时间。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// Date 减去 Last-Modified 值的 10% 作为缓存时间。\n// Date：创建报文的日期时间, Last-Modified 服务器声明文档最后被修改时间\n  response_is_fresh =  max(0,（Date -  Last-Modified)) % 10\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("h3",{attrs:{id:"_2-缓存位置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-缓存位置"}},[e._v("#")]),e._v(" 2.缓存位置")]),e._v(" "),s("blockquote",[s("p",[e._v("通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。")])]),e._v(" "),s("p",[e._v("浏览器缓存并非是一个“总体”概念，其实它也是有先后顺序的。总的来说分为以下4个方面。")]),e._v(" "),s("ul",[s("li",[e._v("Memory Cache")]),e._v(" "),s("li",[e._v("Service Worker Cache")]),e._v(" "),s("li",[e._v("Disk Cache")]),e._v(" "),s("li",[e._v("Push Cache")])]),e._v(" "),s("h4",{attrs:{id:"_2-1-memory-cache"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-memory-cache"}},[e._v("#")]),e._v(" "),s("strong",[e._v("2.1 Memory Cache")])]),e._v(" "),s("p",[e._v("Memory Cacha是指内存中的缓存。它是浏览器优先去命中的一种缓存，也是响应速度最快的一种缓存。但是它的缺点是缓存时间短，关闭tab页面缓存将不复存在，它与浏览器渲染进程紧密联系。")]),e._v(" "),s("p",[e._v("那么哪一些文件会被放到这一缓存里面呢？其实这没有官方的说明，由于浏览器的内存非常有限，浏览器并不会把所有文件都缓存在此处。一般来说会缓存一些体积不大的js或者css文件。")]),e._v(" "),s("h4",{attrs:{id:"_2-2-service-worker-cache"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-service-worker-cache"}},[e._v("#")]),e._v(" "),s("strong",[e._v("2.2 Service Worker Cache")])]),e._v(" "),s("p",[e._v("Service Worker 是一种独立于主线程之外的javascript线程。它脱离于浏览器窗体，因此无法直接访问DOM元素。所以这一个独立的线程能够在不干扰主线程的情况下来提升性能。Service Worker 的缓存与浏览器内建的其他缓存机制不一样，它可以让我们自由缓存哪一些文件、如何匹配缓存等，且缓存具有持续性。")]),e._v(" "),s("p",[e._v("实现该缓存一般分为3个步骤：首先注册Service Worker ，然后监听install事件就可以缓存我们想要的文件。用户下次访问可以通过拦截请求的方式来获取缓存数据。若没有则会重新获取数据，然后再进行缓存。")]),e._v(" "),s("p",[e._v("PS：大家注意 Server Worker 对协议是有要求的，必须以 https 协议为前提。")]),e._v(" "),s("h4",{attrs:{id:"_2-3-disk-cache"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-disk-cache"}},[e._v("#")]),e._v(" 2.3 Disk Cache")]),e._v(" "),s("p",[e._v("Disk Cache也就是硬盘缓存。这种缓存的缓存位置在电脑硬盘上，什么文件都可以缓存，就是读取速度慢。所有缓存中，它的覆盖面是最广的，会根据HTTP Header中的字段判断哪一些资源需要缓存，哪些可以不请求直接使用，哪一些已过期需要重新请求。")]),e._v(" "),s("p",[e._v("浏览器通常会把哪些文件放进缓存呢?")]),e._v(" "),s("ul",[s("li",[e._v("大体积文件")]),e._v(" "),s("li",[e._v("系统内存使用率高")])]),e._v(" "),s("h4",{attrs:{id:"_2-4-push-cache"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-push-cache"}},[e._v("#")]),e._v(" 2.4 Push Cache")]),e._v(" "),s("p",[e._v("Push Cache又名推送缓存，是HTTP/2中的内容，只有以上三种缓存未正确命中，它才会使用。仅存在于会话阶段（session），结束就会释放，缓存时间短。")]),e._v(" "),s("p",[e._v("由于国内用的比较少，网上查找后总结几个结论：")]),e._v(" "),s("ul",[s("li",[e._v("Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。")]),e._v(" "),s("li",[e._v("不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache")]),e._v(" "),s("li",[e._v("Push Cache 是缓存的最后一道防线。浏览器均未命中以上的情况下才会去询问 Push Cache。")]),e._v(" "),s("li",[e._v("Push Cache中的缓存只能被使用一次。")])]),e._v(" "),s("p",[s("strong",[e._v("原文链接：https://zhuanlan.zhihu.com/p/104486657")])]),e._v(" "),s("h2",{attrs:{id:"本地缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#本地缓存"}},[e._v("#")]),e._v(" 本地缓存")]),e._v(" "),s("p",[e._v("浏览器本地缓存主要有 "),s("code",[e._v("cookie")]),e._v(" 、"),s("code",[e._v("localStorage")]),e._v(" 、 "),s("code",[e._v("sessionStorage")])]),e._v(" "),s("h4",{attrs:{id:"_1、cookie"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、cookie"}},[e._v("#")]),e._v(" 1、cookie")]),e._v(" "),s("ul",[s("li",[e._v("1.兼容所有的浏览器")]),e._v(" "),s("li",[e._v("2.有存储的大小限制，一般同源（一个域下）只能存储"),s("code",[e._v("4KB")]),e._v("内容")]),e._v(" "),s("li",[e._v("3."),s("code",[e._v("cookie")]),e._v("有过期时间(当然我们自己可以手动设置这个时间)")]),e._v(" "),s("li",[e._v("4.杀毒软件或者浏览器的垃圾清理都可能会把cookie信息强制清除掉")]),e._v(" "),s("li",[e._v("5.在隐私或者无痕浏览模式下，是不记录cookie的")]),e._v(" "),s("li",[e._v("6."),s("code",[e._v("cookie")]),e._v("不是严格的本地存储，因为要和服务器之间来回传输")])]),e._v(" "),s("h4",{attrs:{id:"_2、localstorage"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、localstorage"}},[e._v("#")]),e._v(" 2、localStorage")]),e._v(" "),s("ul",[s("li",[e._v("不兼容IE8及以下")]),e._v(" "),s("li",[e._v("也有存储的大小限制，同源下一般最多只能存储"),s("code",[e._v("5MB")]),e._v("左右（IE为"),s("code",[e._v("3120kb")]),e._v("）")]),e._v(" "),s("li",[e._v("本地永久存储，只要你不手动删除，永远存储在本地（可以使用 "),s("code",[e._v("removeItem")]),e._v("/"),s("code",[e._v("clear")]),e._v("手动清除一些自己想要删除的信息）")]),e._v(" "),s("li",[e._v("杀毒软件或者浏览器的垃圾清理暂时不会清除"),s("code",[e._v("localStorage")]),e._v("（新版本谷歌浏览器会清除"),s("code",[e._v("localStorage")]),e._v("等信息）")]),e._v(" "),s("li",[e._v("在隐私或者无痕浏览模式下，是记录"),s("code",[e._v("localStorage")]),e._v("的")]),e._v(" "),s("li",[s("code",[e._v("localStorage")]),e._v("和服务器没有半毛钱关系")])]),e._v(" "),s("h4",{attrs:{id:"_3、sessionstorage"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、sessionstorage"}},[e._v("#")]),e._v(" 3、sessionStorage")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("sessionStorage")]),e._v(" 和"),s("code",[e._v("localStorage")]),e._v(" 唯一的区别在于"),s("code",[e._v("sessionStorage")]),e._v(" 是临时存储，只对当前回话有效，当浏览器当前标签页关闭则失效，与"),s("code",[e._v("localStorage")]),e._v(" 拥有同样的方法。")]),e._v(" "),s("li",[s("code",[e._v("localStorageh")]),e._v("和"),s("code",[e._v("sessionStorage")]),e._v(" 都只拥有大约"),s("code",[e._v("5M")]),e._v("的存储空间，不适用于存储大数据量数据。对于数据量较大的数据缓存，我们应该应用本地数据库实现（"),s("code",[e._v("indexDB")]),e._v("）")])]),e._v(" "),s("h4",{attrs:{id:"_4、indexeddb"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、indexeddb"}},[e._v("#")]),e._v(" 4、indexedDB")]),e._v(" "),s("p",[s("code",[e._v("IndexedDB")]),e._v(" 具有以下特点。")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("键值对储存。")]),e._v(" "),s("blockquote",[s("p",[e._v('IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以"键值对"的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。')])])]),e._v(" "),s("li",[s("p",[e._v("异步。")]),e._v(" "),s("blockquote",[s("p",[e._v("IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。")])])]),e._v(" "),s("li",[s("p",[e._v("支持事务。")]),e._v(" "),s("blockquote",[s("p",[e._v("IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。")])])]),e._v(" "),s("li",[s("p",[e._v("同源限制")]),e._v(" "),s("blockquote",[s("p",[e._v("IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。")])])]),e._v(" "),s("li",[s("p",[e._v("储存空间大")]),e._v(" "),s("blockquote",[s("p",[e._v("IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。")])])]),e._v(" "),s("li",[s("p",[e._v("支持二进制储存。")]),e._v(" "),s("blockquote",[s("p",[e._v("IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。")])])])])])}),[],!1,null,null,null);a.default=v.exports}}]);