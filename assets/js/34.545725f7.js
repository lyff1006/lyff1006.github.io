(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{636:function(t,h,a){"use strict";a.r(h);var s=a(6),r=Object(s.a)({},(function(){var t=this,h=t.$createElement,a=t._self._c||h;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("众所周知，前端路由有hash和history两种模式，这里简单的谈谈这两种模式的区别。")]),t._v(" "),a("h1",{attrs:{id:"_1-hash模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-hash模式"}},[t._v("#")]),t._v(" 1.hash模式")]),t._v(" "),a("p",[t._v("hash模式简单的来说就是通过监听url中的hash的变化，然后渲染出不同的内容。")]),t._v(" "),a("p",[t._v("hash指的是url中#号以及后面的字符。本来是用来做页面定位的，它可以使对应的元素在可视区域内显示。由于hash值的改变会触发hashchange事件，浏览器的前进后退功能也能对其进行控制，所以在html5的history出现之前基本都是使用hash来实现前端路由的。")]),t._v(" "),a("blockquote",[a("p",[t._v("特点：")]),t._v(" "),a("p",[t._v("1.hash虽然出现在url中，但是不会被包含在http请求中，因此改变hash值不会重新加载页面。")]),t._v(" "),a("p",[t._v("2.hash本来使用来做页面定位的，如果用来做路由的话，原本的锚点功能则不能使用了。")])]),t._v(" "),a("h1",{attrs:{id:"_2-history模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-history模式"}},[t._v("#")]),t._v(" 2.history模式")]),t._v(" "),a("p",[t._v("history模式主要使利用了利用了HTML5中新增的pushState（）和replaceState（）方法。注意history需要浏览器支持，不能应用与ie8以下。")]),t._v(" "),a("blockquote",[a("p",[t._v("window.history中常用的方法")]),t._v(" "),a("ul",[a("li",[t._v("back()：后退到上一个路由；")]),t._v(" "),a("li",[t._v("forward()：前进到下一个路由，如果有的话；")]),t._v(" "),a("li",[t._v("go(number)：进入到任意一个路由，正数为前进，负数为后退；")]),t._v(" "),a("li",[t._v("pushState(obj, title, url)：前进到指定的 URL，不刷新页面；")]),t._v(" "),a("li",[t._v("replaceState(obj, title, url)：用 url 替换当前的路由，不刷新页面；")])])])])}),[],!1,null,null,null);h.default=r.exports}}]);